// -------------------------------------------------------------
//
// Module: decimator
// Generated by MATLAB(R) 8.1 and the Filter Design HDL Coder 2.9.3.
// Generated on: 2015-04-11 21:57:24
// -------------------------------------------------------------

// -------------------------------------------------------------
// HDL Code Generation Options:
//
// OptimizeForHDL: on
// ClockEnableInputPort: enable
// ResetInputPort: rstn
// Name: decimator
// ResetAssertedLevel: Active-low
// TargetLanguage: Verilog
// TestBenchStimulus: step ramp chirp noise 

// -------------------------------------------------------------
// HDL Implementation    : Fully parallel
// -------------------------------------------------------------
// Filter Settings:
//
// Discrete-Time FIR Multirate Filter (real)
// -----------------------------------------
// Filter Structure        : Cascaded Integrator-Comb Decimator
// Decimation Factor       : 16
// Differential Delay      : 2
// Number of Sections      : 3
// Stable                  : Yes
// Linear Phase            : Yes (Type 2)
//
// Input                   : s6,5
// Output                  : s21,5
// Filter Internals        : Minimum Word Lengths
//   Integrator Section 1  : s21,5
//   Integrator Section 2  : s21,5
//   Integrator Section 3  : s21,5
//   Comb Section 1        : s21,5
//   Comb Section 2        : s21,5
//   Comb Section 3        : s21,5
// -------------------------------------------------------------


module decimator
               (
                clk,
                enable,
                rstn,
                filter_in,
                filter_out,
                ce_out
                );

  input   clk; 
  input   enable; 
  input   rstn; 
  input   [4:0] filter_in; //sfix6_En5
//  output  [14:0] filter_out; //sfix21_En5
  output  [20:0] filter_out; //sfix21_En5
  output  ce_out; 

////////////////////////////////////////////////////////////////
//Module Architecture: decimator
////////////////////////////////////////////////////////////////
  // Local Functions
  // Type Definitions
  // Constants
  // Signals
  reg  [3:0] cur_count; // ufix4
  wire phase_1; // boolean
  reg  ce_out_reg; // boolean
  //   
  reg  signed [5:0] input_register; // sfix6_En5
  //   -- Section 1 Signals 
  wire signed [5:0] section_in1; // sfix6_En5
  wire signed [20:0] section_cast1; // sfix21_En5
  wire signed [20:0] sum1; // sfix21_En5
  reg  signed [20:0] section_out1; // sfix21_En5
  wire signed [20:0] add_cast; // sfix21_En5
  wire signed [20:0] add_cast_1; // sfix21_En5
  wire signed [21:0] add_temp; // sfix22_En5
  //   -- Section 2 Signals 
  wire signed [20:0] section_in2; // sfix21_En5
  wire signed [20:0] sum2; // sfix21_En5
  reg  signed [20:0] section_out2; // sfix21_En5
  wire signed [20:0] add_cast_2; // sfix21_En5
  wire signed [20:0] add_cast_3; // sfix21_En5
  wire signed [21:0] add_temp_1; // sfix22_En5
  //   -- Section 3 Signals 
  wire signed [20:0] section_in3; // sfix21_En5
  wire signed [20:0] sum3; // sfix21_En5
  reg  signed [20:0] section_out3; // sfix21_En5
  wire signed [20:0] add_cast_4; // sfix21_En5
  wire signed [20:0] add_cast_5; // sfix21_En5
  wire signed [21:0] add_temp_2; // sfix22_En5
  //   -- Section 4 Signals 
  wire signed [20:0] section_in4; // sfix21_En5
  wire signed [20:0] diff1; // sfix21_En5
  wire signed [20:0] section_out4; // sfix21_En5
  wire signed [20:0] sub_cast; // sfix21_En5
  wire signed [20:0] sub_cast_1; // sfix21_En5
  wire signed [21:0] sub_temp; // sfix22_En5
  reg  signed [20:0] int_delay_pipe [0:1] ; // sfix21_En5
  //   -- Section 5 Signals 
  wire signed [20:0] section_in5; // sfix21_En5
  wire signed [20:0] diff2; // sfix21_En5
  wire signed [20:0] section_out5; // sfix21_En5
  wire signed [20:0] sub_cast_2; // sfix21_En5
  wire signed [20:0] sub_cast_3; // sfix21_En5
  wire signed [21:0] sub_temp_1; // sfix22_En5
  reg  signed [20:0] int_delay_pipe_1 [0:1] ; // sfix21_En5
  //   -- Section 6 Signals 
  wire signed [20:0] section_in6; // sfix21_En5
  wire signed [20:0] diff3; // sfix21_En5
  wire signed [20:0] section_out6; // sfix21_En5
  wire signed [20:0] sub_cast_4; // sfix21_En5
  wire signed [20:0] sub_cast_5; // sfix21_En5
  wire signed [21:0] sub_temp_2; // sfix22_En5
  reg  signed [20:0] int_delay_pipe_2 [0:1] ; // sfix21_En5
  //   
  reg  signed [20:0] output_register; // sfix21_En5

  // Block Statements
  //   ------------------ CE Output Generation ------------------

  always @ (posedge clk or negedge rstn)
    begin: ce_output
      if (rstn == 1'b0) begin
        cur_count <= 4'b0000;
      end
      else begin
        if (enable == 1'b1) begin
          if (cur_count == 4'b1111) begin
            cur_count <= 4'b0000;
          end
          else begin
            cur_count <= cur_count + 1'b1;
          end
        end
      end
    end // ce_output

  assign  phase_1 = (cur_count == 4'b0001 && enable == 1'b1)? 1'b1 : 1'b0;

  //   ------------------ CE Output Register ------------------

  always @ (posedge clk or negedge rstn)
    begin: ce_output_register
      if (rstn == 1'b0) begin
        ce_out_reg <= 1'b0;
      end
      else begin
          ce_out_reg <= phase_1;
      end
    end // ce_output_register

  //   ------------------ Input Register ------------------

  always @ (posedge clk or negedge rstn)
    begin: input_reg_process
      if (rstn == 1'b0) begin
        input_register <= 0;
      end
      else begin
        if (enable == 1'b1) begin
          input_register <= {1'b0,filter_in};
        end
      end
    end // input_reg_process

  //   ------------------ Section # 1 : Integrator ------------------

  assign section_in1 = input_register;

  assign section_cast1 = $signed({{15{section_in1[5]}}, section_in1});

  assign add_cast = section_cast1;
  assign add_cast_1 = section_out1;
  assign add_temp = add_cast + add_cast_1;
  assign sum1 = add_temp[20:0];

  always @ (posedge clk or negedge rstn)
    begin: integrator_delay_section1
      if (rstn == 1'b0) begin
        section_out1 <= 0;
      end
      else begin
        if (enable == 1'b1) begin
          section_out1 <= sum1;
        end
      end
    end // integrator_delay_section1

  //   ------------------ Section # 2 : Integrator ------------------

  assign section_in2 = section_out1;

  assign add_cast_2 = section_in2;
  assign add_cast_3 = section_out2;
  assign add_temp_1 = add_cast_2 + add_cast_3;
  assign sum2 = add_temp_1[20:0];

  always @ (posedge clk or negedge rstn)
    begin: integrator_delay_section2
      if (rstn == 1'b0) begin
        section_out2 <= 0;
      end
      else begin
        if (enable == 1'b1) begin
          section_out2 <= sum2;
        end
      end
    end // integrator_delay_section2

  //   ------------------ Section # 3 : Integrator ------------------

  assign section_in3 = section_out2;

  assign add_cast_4 = section_in3;
  assign add_cast_5 = section_out3;
  assign add_temp_2 = add_cast_4 + add_cast_5;
  assign sum3 = add_temp_2[20:0];

  always @ (posedge clk or negedge rstn)
    begin: integrator_delay_section3
      if (rstn == 1'b0) begin
        section_out3 <= 0;
      end
      else begin
        if (enable == 1'b1) begin
          section_out3 <= sum3;
        end
      end
    end // integrator_delay_section3

  //   ------------------ Section # 4 : Comb ------------------

  assign section_in4 = section_out3;

  assign sub_cast = section_in4;
  assign sub_cast_1 = diff1;
  assign sub_temp = sub_cast - sub_cast_1;
  assign section_out4 = sub_temp[20:0];

  always @ (posedge clk or negedge rstn)
    begin: comb_delay_section4
      if (rstn == 1'b0) begin
        int_delay_pipe[0] <= 21'b000000000000000000000;
        int_delay_pipe[1] <= 21'b000000000000000000000;
      end
      else begin
        if (phase_1 == 1'b1) begin
          int_delay_pipe[1] <= int_delay_pipe[0];
          int_delay_pipe[0] <= section_in4;
        end
      end
    end // comb_delay_section4
  assign diff1 = int_delay_pipe[1];

  //   ------------------ Section # 5 : Comb ------------------

  assign section_in5 = section_out4;

  assign sub_cast_2 = section_in5;
  assign sub_cast_3 = diff2;
  assign sub_temp_1 = sub_cast_2 - sub_cast_3;
  assign section_out5 = sub_temp_1[20:0];

  always @ (posedge clk or negedge rstn)
    begin: comb_delay_section5
      if (rstn == 1'b0) begin
        int_delay_pipe_1[0] <= 21'b000000000000000000000;
        int_delay_pipe_1[1] <= 21'b000000000000000000000;
      end
      else begin
        if (phase_1 == 1'b1) begin
          int_delay_pipe_1[1] <= int_delay_pipe_1[0];
          int_delay_pipe_1[0] <= section_in5;
        end
      end
    end // comb_delay_section5
  assign diff2 = int_delay_pipe_1[1];

  //   ------------------ Section # 6 : Comb ------------------

  assign section_in6 = section_out5;

  assign sub_cast_4 = section_in6;
  assign sub_cast_5 = diff3;
  assign sub_temp_2 = sub_cast_4 - sub_cast_5;
  assign section_out6 = sub_temp_2[20:0];

  always @ (posedge clk or negedge rstn)
    begin: comb_delay_section6
      if (rstn == 1'b0) begin
        int_delay_pipe_2[0] <= 21'b000000000000000000000;
        int_delay_pipe_2[1] <= 21'b000000000000000000000;
      end
      else begin
        if (phase_1 == 1'b1) begin
          int_delay_pipe_2[1] <= int_delay_pipe_2[0];
          int_delay_pipe_2[0] <= section_in6;
        end
      end
    end // comb_delay_section6
  assign diff3 = int_delay_pipe_2[1];

  //   ------------------ Output Register ------------------

  always @ (posedge clk or negedge rstn)
    begin: output_reg_process
      if (rstn == 1'b0) begin
        output_register <= 0;
      end
      else begin
        if (phase_1 == 1'b1) begin
          output_register <= section_out6;
        end
      end
    end // output_reg_process

  // Assignment Statements
  assign ce_out = ce_out_reg;
//  assign filter_out = output_register[19:5];
  assign filter_out = output_register;
endmodule  // decimator
